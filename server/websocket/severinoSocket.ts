import { WebSocketServer, WebSocket } from 'ws';
import { WebSocketMessage, WebSocketConnection, SeverinoNotification } from '../types/severino';

class SeverinoWebSocket {
  private wss: WebSocketServer;
  private connections: Map<string, WebSocketConnection> = new Map();
  private userConnections: Map<string, string[]> = new Map(); // userId -> connectionIds[]

  constructor(server: any) {
    this.wss = new WebSocketServer({ 
      server,
      path: '/ws/severino' // Path espec√≠fico para evitar conflito com HMR
    });
    this.initialize();
  }

  private initialize() {
    this.wss.on('connection', (ws: WebSocket, request: any) => {
      const connectionId = this.generateConnectionId();
      const ipAddress = request.socket.remoteAddress;
      const userAgent = request.headers['user-agent'] || 'Unknown';

      console.log(`üîå Nova conex√£o WebSocket: ${connectionId}`);

      // Extrair userId do token ou query params
      const url = new URL(request.url, `http://${request.headers.host}`);
      const userId = url.searchParams.get('userId') || 'anonymous';

      const connection: WebSocketConnection = {
        id: connectionId,
        userId,
        connectedAt: new Date(),
        lastActivity: new Date(),
        userAgent,
        ipAddress
      };

      this.connections.set(connectionId, connection);
      
      // Mapear usu√°rio para conex√µes
      if (!this.userConnections.has(userId)) {
        this.userConnections.set(userId, []);
      }
      this.userConnections.get(userId)!.push(connectionId);

      // Enviar mensagem de boas-vindas
      this.sendToConnection(connectionId, {
        type: 'status_update',
        data: {
          status: 'connected',
                              message: 'Conectado ao Severino Assistant',
          timestamp: new Date()
        },
        timestamp: new Date(),
        userId
      });

      // Configurar handlers de mensagem
      ws.on('message', (data: Buffer) => {
        try {
          const message: WebSocketMessage = JSON.parse(data.toString());
          this.handleMessage(connectionId, message);
        } catch (error) {
          console.error('Erro ao processar mensagem WebSocket:', error);
          this.sendToConnection(connectionId, {
            type: 'error',
            data: {
              error: 'Mensagem inv√°lida',
              details: error instanceof Error ? error.message : 'Unknown error'
            },
            timestamp: new Date()
          });
        }
      });

      // Configurar handler de desconex√£o
      ws.on('close', () => {
        this.handleDisconnection(connectionId);
      });

      // Configurar handler de erro
      ws.on('error', (error) => {
        console.error(`Erro na conex√£o WebSocket ${connectionId}:`, error);
        this.handleDisconnection(connectionId);
      });

      // Armazenar refer√™ncia do WebSocket
      (ws as any).connectionId = connectionId;
    });
  }

  private handleMessage(connectionId: string, message: WebSocketMessage) {
    const connection = this.connections.get(connectionId);
    if (!connection) {
      console.error(`Conex√£o n√£o encontrada: ${connectionId}`);
      return;
    }

    // Atualizar √∫ltima atividade
    connection.lastActivity = new Date();

    console.log(`üì® Mensagem recebida de ${connection.userId}:`, message.type);

    switch (message.type) {
      case 'message':
        this.handleChatMessage(connectionId, message);
        break;
      case 'action':
        this.handleActionRequest(connectionId, message);
        break;
      case 'notification':
        this.handleNotificationAck(connectionId, message);
        break;
      case 'status_update':
        this.handleStatusUpdate(connectionId, message);
        break;
      default:
        console.warn(`Tipo de mensagem desconhecido: ${message.type}`);
    }
  }

  private handleChatMessage(connectionId: string, message: WebSocketMessage) {
    // Aqui voc√™ pode integrar com o Gemini Service
    // Por enquanto, vamos simular uma resposta
    setTimeout(() => {
      this.sendToConnection(connectionId, {
        type: 'message',
        data: {
          role: 'assistant',
                              content: 'Ol√°! Sou o Severino. Como posso ajudar voc√™ hoje?',
          timestamp: new Date()
        },
        timestamp: new Date(),
        userId: message.userId
      });
    }, 1000);
  }

  private handleActionRequest(connectionId: string, message: WebSocketMessage) {
    // Processar a√ß√µes solicitadas pelo usu√°rio
    const action = message.data;
    
    // Simular processamento de a√ß√£o
    this.sendToConnection(connectionId, {
      type: 'action',
      data: {
        status: 'processing',
        action: action.type,
        message: 'Processando sua solicita√ß√£o...'
      },
      timestamp: new Date(),
      userId: message.userId
    });

    // Aqui voc√™ pode integrar com os scripts Python de automa√ß√£o
    setTimeout(() => {
      this.sendToConnection(connectionId, {
        type: 'action',
        data: {
          status: 'completed',
          action: action.type,
          result: 'A√ß√£o executada com sucesso!'
        },
        timestamp: new Date(),
        userId: message.userId
      });
    }, 2000);
  }

  private handleNotificationAck(connectionId: string, message: WebSocketMessage) {
    // Marcar notifica√ß√£o como lida
    const notificationId = message.data.notificationId;
    console.log(`Notifica√ß√£o ${notificationId} marcada como lida por ${connectionId}`);
  }

  private handleStatusUpdate(connectionId: string, message: WebSocketMessage) {
    // Atualizar status da conex√£o
    const connection = this.connections.get(connectionId);
    if (connection) {
      connection.lastActivity = new Date();
    }
  }

  private handleDisconnection(connectionId: string) {
    const connection = this.connections.get(connectionId);
    if (connection) {
      console.log(`üîå Desconex√£o: ${connectionId} (${connection.userId})`);
      
      // Remover da lista de conex√µes
      this.connections.delete(connectionId);
      
      // Remover do mapeamento de usu√°rio
      const userConnections = this.userConnections.get(connection.userId);
      if (userConnections) {
        const index = userConnections.indexOf(connectionId);
        if (index > -1) {
          userConnections.splice(index, 1);
          if (userConnections.length === 0) {
            this.userConnections.delete(connection.userId);
          }
        }
      }
    }
  }

  // M√©todos p√∫blicos para envio de mensagens

  public sendToUser(userId: string, message: WebSocketMessage) {
    const userConnections = this.userConnections.get(userId);
    if (userConnections) {
      userConnections.forEach(connectionId => {
        this.sendToConnection(connectionId, message);
      });
    }
  }

  public sendToAll(message: WebSocketMessage) {
    this.wss.clients.forEach((client: WebSocket) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }

  public sendToConnection(connectionId: string, message: WebSocketMessage) {
    this.wss.clients.forEach((client: WebSocket) => {
      if ((client as any).connectionId === connectionId && client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }

  public sendNotification(userId: string, notification: SeverinoNotification) {
    this.sendToUser(userId, {
      type: 'notification',
      data: notification,
      timestamp: new Date(),
      userId
    });
  }

  public sendProactiveHelp(userId: string, helpData: any) {
    this.sendToUser(userId, {
      type: 'message',
      data: {
        role: 'assistant',
        content: helpData.message,
        suggestions: helpData.suggestions,
        timestamp: new Date()
      },
      timestamp: new Date(),
      userId
    });
  }

  public sendAutomationStatus(userId: string, taskId: string, status: string, result?: any) {
    this.sendToUser(userId, {
      type: 'action',
      data: {
        taskId,
        status,
        result,
        timestamp: new Date()
      },
      timestamp: new Date(),
      userId
    });
  }

  // M√©todos de utilidade

  private generateConnectionId(): string {
    return `conn_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  public getConnectionStats() {
    return {
      totalConnections: this.connections.size,
      activeUsers: this.userConnections.size,
      connectionsByUser: Object.fromEntries(
        Array.from(this.userConnections.entries()).map(([userId, connections]) => [
          userId,
          connections.length
        ])
      )
    };
  }

  public cleanupInactiveConnections(timeoutMinutes: number = 30) {
    const now = new Date();
    const timeoutMs = timeoutMinutes * 60 * 1000;

    this.connections.forEach((connection, connectionId) => {
      if (now.getTime() - connection.lastActivity.getTime() > timeoutMs) {
        console.log(`Limpeza: Removendo conex√£o inativa ${connectionId}`);
        this.handleDisconnection(connectionId);
      }
    });
  }

  // M√©todo para integra√ß√£o com o Gemini Service
  public async processSeverinoResponse(userId: string, userInput: string, response: string) {
    this.sendToUser(userId, {
      type: 'message',
      data: {
        role: 'assistant',
        content: response,
        timestamp: new Date()
      },
      timestamp: new Date(),
      userId
    });
  }

  // M√©todo para enviar alertas cr√≠ticos
  public sendCriticalAlert(userIds: string[], alert: {
    title: string;
    message: string;
    priority: 'high' | 'critical';
    action?: any;
  }) {
    const message: WebSocketMessage = {
      type: 'notification',
      data: {
        id: `alert_${Date.now()}`,
        type: alert.priority === 'critical' ? 'error' : 'warning',
        title: alert.title,
        message: alert.message,
        timestamp: new Date(),
        read: false,
        action: alert.action,
        priority: alert.priority
      },
      timestamp: new Date()
    };

    userIds.forEach(userId => {
      this.sendToUser(userId, message);
    });
  }
}

export default SeverinoWebSocket;
